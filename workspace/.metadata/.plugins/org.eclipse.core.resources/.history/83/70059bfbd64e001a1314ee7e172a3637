package algospot;

import java.util.*;

class TreeNode {
	int x, y, r;
	ArrayList<TreeNode> childNode;
	
	public TreeNode(int x, int y, int r) {
		this.x = x;
		this.y = y;
		this.r = r;
		childNode = new ArrayList<>();
	}
	
	public void addChild(TreeNode child) {
		this.childNode.add(child);
	}
}

public class Fortress {

	static int n;
	static int[] x = new int[100];
	static int[] y = new int[100];
	static int[] r = new int[100];
	
	static int longest;
	
	public static void main(String[] args) {
		// TODO Auto-generated method stub
		Scanner scan = new Scanner(System.in);
		int c = scan.nextInt();
		
		for(int test=1; test<=c; test++) {
			n = scan.nextInt();
			
			for(int i=0; i<n; i++) {
				x[i] = scan.nextInt();
				y[i] = scan.nextInt();
				r[i] = scan.nextInt();
				
			}
		}
	}
	
	public static int sqr(int x) {
		return x*x;
	}
	
	public static int sqrdist(int a, int b) {
		return sqr(y[a] - y[b]) + sqr(x[a] - x[b]);
	}
	
	// 성벽 a가 성벽 b를 포함하는지 확인
	public boolean encloses(int a, int b) {
		return r[a] > r[b] &&
				sqrdist(a, b) < sqr(r[a]-r[b]);
	}
	
	// parent가 child의 부모인지 확인
	// parent는 child를 직접 포함해야 함
	boolean isChild(int parent, int child) {
		if(!encloses(parent, child)) {
			return false;
		}
		
		for(int i=0; i<n; i++) {
			if(i != parent && i != child && encloses(parent, i) && encloses(i, child)) {
				return false;
			}
		}
		return true;
	}
	
	// root 성벽을 루트로 하는 트리 생성
	TreeNode getTree(int root) {
		TreeNode ret = new TreeNode(x, y, r);
		
		for(int ch=0; ch<n; ch++) {
			// ch 성벽이 root 성벽에 직접포함이면
			// 트리 만들고 자손에 추가
			if(isChild(root, ch)) {
				ret.childNode.add(getTree(ch));
			}
		}
		return ret;
	}
	
	
	// root를 루트로 하는 서브트리의 높이 계산
	public int height(TreeNode root) {
		// 각 자식을 루트로 하는 서브트리의 높이 계산
		ArrayList<Integer> heights = new ArrayList<>();
		for(int i=0; i<root.childNode.size(); i++) {
			heights.add(height(root.childNode.get(i)));
		}
		
		// 만약 자식이 없다면 0 반환
		if(heights.isEmpty()) {
			return 0;
		}
		
		Collections.sort(heights);
		
		// root을 최상위 노드로 하는 경로 고려
		if(heights.size() >= 2) {
			longest = Math.max(longest, 
					2 + heights.get(heights.size()-2) + heights.get(heights.size()-1));
		}
		
		// 트리의 높이는 서브트리 높이의 최대치에 1을 더함
		return heights.get(heights.size()-1);
	}
	
	// 두 노드 사이의 가장 긴 경로의 길이를 계산한다.
	public int solve(TreeNode root) {
		longest = 0;
		
		// 트리의 높이와 최대 잎-잎 경로 중 큰 것
		int h = height(root);
		return Math.max(longest, h);
	}
}
